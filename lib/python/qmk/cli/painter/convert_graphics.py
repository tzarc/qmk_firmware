"""This script automates the conversion of graphics files into a format QMK firmware understands.
"""
import re
import datetime
import qmk.path
from qmk.painter import palettize_image, image_to_rgb565
from string import Template
from PIL import Image
from milc import cli

license_template = """\
/* Copyright ${year} QMK
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This file was auto-generated by `qmk painter-convert-graphics -i ${input_file} -f ${format}`
 */
"""

header_file_template = """\
${license}

#pragma once

#include <qp.h>

extern painter_image_t gfx_${sane_name} PROGMEM;
"""

palette_template = """\
static const uint8_t gfx_${sane_name}_palette[${palette_byte_size}] PROGMEM = {
${palette_lines}
};

"""

palette_line_template = """\
    0x${r}, 0x${g}, 0x${b}, // #${r}${g}${b} - ${idx}
"""

uncompressed_source_file_template = """\
${license}

#include <progmem.h>
#include <stdint.h>
#include <qp.h>
#include <qp_internal.h>

// clang-format off

${palette}

static const uint8_t gfx_${sane_name}_data[${byte_count}] PROGMEM = {
${bytes_lines}
};

static const painter_raw_image_descriptor_t gfx_${sane_name}_raw PROGMEM = {
    .base = {
        .image_format = ${image_format},
        .image_bpp    = ${image_bpp},
        .compression  = IMAGE_UNCOMPRESSED,
        .width        = ${image_width},
        .height       = ${image_height}
    },
    .image_palette = ${palette_ptr},
    .byte_count    = ${byte_count},
    .image_data    = gfx_${sane_name}_data,
};

painter_image_t gfx_${sane_name} PROGMEM = (painter_image_t)&gfx_${sane_name}_raw;

// clang-format on
"""

valid_formats = {
    'rgb565': {
        'image_format': 'IMAGE_FORMAT_RGB565',
        'bpp': 16,
    },
    'pal256': {
        'image_format': 'IMAGE_FORMAT_PALETTE',
        'bpp': 8,
        'has_palette': True,
        'num_colors': 256,
    },
    'pal16': {
        'image_format': 'IMAGE_FORMAT_PALETTE',
        'bpp': 4,
        'has_palette': True,
        'num_colors': 16,
    },
    'pal4': {
        'image_format': 'IMAGE_FORMAT_PALETTE',
        'bpp': 2,
        'has_palette': True,
        'num_colors': 4,
    },
    'pal2': {
        'image_format': 'IMAGE_FORMAT_PALETTE',
        'bpp': 1,
        'has_palette': True,
        'num_colors': 2,
    },
    'mono256': {
        'image_format': 'IMAGE_FORMAT_GRAYSCALE',
        'bpp': 8,
        'has_palette': False,
        'num_colors': 256,
    },
    'mono16': {
        'image_format': 'IMAGE_FORMAT_GRAYSCALE',
        'bpp': 4,
        'has_palette': False,
        'num_colors': 16,
    },
    'mono4': {
        'image_format': 'IMAGE_FORMAT_GRAYSCALE',
        'bpp': 2,
        'has_palette': False,
        'num_colors': 4,
    },
    'mono2': {
        'image_format': 'IMAGE_FORMAT_GRAYSCALE',
        'bpp': 1,
        'has_palette': False,
        'num_colors': 2,
    }
}


def clean_output(str):
    str = re.sub(r'\r', '', str)
    str = re.sub(r'[\n]{3,}', r'\n\n', str)
    return str


def render_license(subs):
    license_src = Template(license_template)
    return license_src.substitute(subs)


def render_header(format, subs):
    header_src = Template(header_file_template)
    return header_src.substitute(subs)


def render_palette(palette, subs):
    palette_lines = ''
    palette_line_src = Template(palette_line_template)
    for n in range(len(palette)):
        rgb = palette[n]
        palette_lines = palette_lines + palette_line_src.substitute({'r': '{0:02X}'.format(rgb[0]), 'g': '{0:02X}'.format(rgb[1]), 'b': '{0:02X}'.format(rgb[2]), 'idx': n})
    palette_src = Template(palette_template)
    subs.update({'palette_byte_size': len(palette) * 3, 'palette_lines': palette_lines.rstrip()})
    return palette_src.substitute(subs).rstrip()


def render_bytes(bytes, subs):
    lines = ''
    for n in range(len(bytes)):
        if n % 32 == 0 and n > 0 and n != len(bytes):
            lines = lines + "\n   "
        elif n == 0:
            lines = lines + "   "
        lines = lines + " 0x{0:02X},".format(bytes[n])
    return lines.rstrip()


def render_source(format, palette, image_data, width, height, subs):
    has_palette = True if 'has_palette' in format and format['has_palette'] is True else False

    subs.update({
        'palette': render_palette(palette, subs) if has_palette else '',
        'palette_ptr': Template("gfx_${sane_name}_palette").substitute(subs) if has_palette else 'NULL',
        'byte_count': len(image_data),
        'bytes_lines': render_bytes(image_data, subs),
    })

    source_src = Template(uncompressed_source_file_template)
    return source_src.substitute(subs)


@cli.argument('-i', '--input', required=True, help='Specify input graphic file.')
@cli.argument('-f', '--format', required=True, help='Output format, valid types: %s' % (', '.join(valid_formats.keys())))
@cli.subcommand('Converts an input image to something QMK understands')
def painter_convert_graphics(cli):
    """Converts an image file to a format that Quantum Painter understands.

    This command uses the `qmk.painter` module to generate a Quantum Painter image defintion from an image. The generated definitions are written to a files next to the input -- `INPUT.c` and `INPUT.h`.
    """
    if cli.args.input != '-':
        cli.args.input = qmk.path.normpath(cli.args.input)

        # Error checking
        if not cli.args.input.exists():
            cli.log.error('Input image file does not exist!')
            cli.print_usage()
            return False

    if cli.args.format not in valid_formats.keys():
        cli.log.error('Output format %s is invalid. Allowed values: %s' % (cli.args.format, ', '.join(valid_formats.keys())))
        cli.print_usage()
        return False

    sane_name = re.sub(r"[^a-zA-Z0-9]", "_", cli.args.input.stem)

    format = valid_formats[cli.args.format]

    graphic_image = Image.open(cli.args.input)
    (width, height) = graphic_image.size
    graphic_data = image_to_rgb565(graphic_image) if cli.args.format == 'rgb565' else palettize_image(graphic_image, ncolors=format['num_colors'], mono=(not format['has_palette']))
    palette = graphic_data[0]
    image_data = graphic_data[1]

    subs = {
        'year': datetime.date.today().strftime("%Y"),
        'input_file': cli.args.input.name,
        'sane_name': sane_name,
        'format': cli.args.format,
        'image_format': format['image_format'],
        'image_bpp': format['bpp'],
        'image_width': width,
        'image_height': height,
    }

    subs.update({
        'license': render_license(subs),
    })

    header_text = clean_output(render_header(format, subs))
    source_text = clean_output(render_source(format, palette, image_data, width, height, subs))

    header_file = cli.args.input.parent / (cli.args.input.stem + ".h")
    with open(header_file, 'w') as header:
        print(f"Writing {header_file}...")
        header.write(header_text)
        header.close()

    source_file = cli.args.input.parent / (cli.args.input.stem + ".c")
    with open(source_file, 'w') as source:
        print(f"Writing {source_file}...")
        source.write(source_text)
        source.close()
